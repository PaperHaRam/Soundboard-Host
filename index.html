<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Soundboard – 호스트(공유자)</title>
<style>
  :root {
    --bg:#0d1117; --surface:#0f141b; --card:#121826; --line:#1f2a3a;
    --muted:#9fb0c9; --text:#ecf2ff; --accent:#6ee7b7; --accent-2:#60a5fa; --warn:#fca5a5;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,sans-serif;}
  header{position:sticky;top:0;z-index:5;backdrop-filter:blur(8px);background:linear-gradient(180deg,rgba(13,17,23,.95),rgba(13,17,23,.75));
    border-bottom:1px solid var(--line);padding:14px 18px;display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:12px}
  .pill{padding:6px 10px;border-radius:999px;background:#0b1220;border:1px solid var(--line);font-size:12px;color:#c7d5f3}
  .btn{background:#182235;border:1px solid #26344d;border-radius:10px;color:var(--text);padding:9px 12px;cursor:pointer;font-weight:700}
  .btn:hover{border-color:#33507a}
  .btn-ghost{background:transparent;border:1px dashed #33425c;color:#cfe0ff}
  .btn-accent{background:linear-gradient(90deg,#10b981,#34d399);border:0;color:#062013}
  .btn-blue{background:linear-gradient(90deg,#3b82f6,#60a5fa);border:0;color:#06152b}
  .btn-danger{background:linear-gradient(90deg,#f43f5e,#fb7185);border:0;color:#2a0107}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:10px}
  main{padding:18px;display:grid;grid-template-columns:2.1fr 1fr;gap:18px}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px}
  .panel h2{margin:0 0 10px 0;font-size:15px}
  .panel .hint{color:var(--muted);font-size:12px}
  .divider{height:1px;background:var(--line);margin:10px 0}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px}
  .card{background:var(--surface);border:1px solid var(--line);border-radius:14px;display:flex;flex-direction:column}
  .card-head{padding:12px;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;gap:8px;align-items:center}
  .title{font-size:14px;font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .badge{font-size:11px;color:#b6c5e3}
  .card-body{padding:10px;display:flex;flex-direction:column;gap:10px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  .kv{display:flex;align-items:center;gap:8px}
  .range{width:100%}
  .small{font-size:12px;color:var(--muted)}
  .hotbar{display:grid;grid-template-columns:repeat(10,1fr);gap:8px}
  .slot{background:#0f1624;border:1px dashed #334469;border-radius:12px;min-height:84px;padding:8px;display:flex;flex-direction:column;gap:6px;justify-content:center;align-items:center}
  .slot .k{font-size:12px;color:#a3b6da}
  .slot .name{font-weight:700;font-size:12px;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center}
  .slot.drag-over{outline:2px dashed #60a5fa; outline-offset:2px}
  .foot{position:fixed;left:16px;bottom:16px;display:flex;gap:10px;align-items:center}
  .codebox{background:#0b111b;border:1px solid var(--line);border-radius:12px;padding:10px 12px;display:flex;gap:10px;align-items:center}
  .code{font-weight:900;font-size:16px;letter-spacing:1px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
  input[type="file"]::-webkit-file-upload-button{visibility:hidden}
  input[type="file"]{color:#9fb0c9}
  .section-head{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:8px}
  .pill-blue{background:#0b1730;border:1px solid #1a3b70}
</style>
</head>
<body>
<header>
  <div class="row">
    <h1>사운드보드 (호스트)</h1>
    <span class="sub">개별 볼륨 / 보드별 마스터 / 반복 재생 / 미니보드 드래그 재정렬 / 프리셋 / 공유 스트리밍</span>
  </div>
  <div class="row">
    <label class="btn">
      파일 업로드
      <input id="fileInput" type="file" accept="audio/*" multiple style="display:none" />
    </label>
  </div>
</header>

<main>
  <!-- 메인 보드 -->
  <section class="panel">
    <div class="section-head">
      <h2>메인 사운드보드</h2>
      <div class="row">
        <button id="stopMain" class="btn btn-danger">메인 전체 정지</button>
        <span class="pill-blue">출력 그룹: 메인</span>
      </div>
    </div>

    <div class="row" style="margin:6px 0 12px 0">
      <div class="kv">
        <span class="pill">보드 마스터 볼륨</span>
        <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.9" />
        <span id="masterVolVal" class="small">0.90</span>
      </div>

      <!-- 프리셋 컨트롤 -->
      <div class="kv" style="margin-left:auto;gap:6px">
        <button id="saveLS" class="btn">로컬 저장</button>
        <button id="loadLS" class="btn">로컬 적용</button>
        <button id="exportPreset" class="btn">프리셋 내보내기</button>
        <label class="btn">
          프리셋 가져오기
          <input id="importPreset" type="file" accept="application/json" style="display:none" />
        </label>
      </div>
    </div>

    <div id="mainGrid" class="grid"></div>
  </section>

  <!-- 오른쪽: 미니 보드 -->
  <aside class="panel">
    <div class="section-head">
      <h2>미니 사운드보드</h2>
      <div class="row">
        <button id="stopMini" class="btn btn-danger">미니 전체 정지</button>
        <span class="pill-blue">출력 그룹: 미니</span>
      </div>
    </div>

    <div class="row" style="margin:6px 0 12px 0">
      <div class="kv">
        <span class="pill">미니보드 마스터 볼륨</span>
        <input id="miniMasterVol" type="range" min="0" max="1" step="0.01" value="0.9" />
        <span id="miniMasterVolVal" class="small">0.90</span>
      </div>
    </div>

    <div id="miniGrid" class="hotbar"></div>
    <div class="divider"></div>
    <div class="small">
      • 슬롯을 <b>드래그&드롭</b>해 순서를 바꿀 수 있습니다(빈 슬롯 포함).<br/>
      • 카드의 “미니보드 할당”으로 슬롯에 배치 → 숫자 키 <b>1~0</b> 즉시 재생.<br/>
      • 메인/미니는 각각 **별도 마스터 볼륨**과 **별도 전체 정지**를 가집니다.
    </div>
  </aside>
</main>

<!-- 좌하단: 공유 코드 생성기 -->
<div class="foot">
  <button id="makeCode" class="btn btn-accent">공유 코드 생성</button>
  <div class="codebox">
    <span class="small">공유 코드</span>
    <span id="shareCode" class="code mono">—</span>
  </div>
  <span id="peerStatus" class="small">대기 중…</span>
</div>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
/** ========= 오디오 그래프 ========= **/
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// 그룹별 마스터
const mainMasterGain = audioCtx.createGain();
const miniMasterGain = audioCtx.createGain();
mainMasterGain.gain.value = 0.9;
miniMasterGain.gain.value = 0.9;

// 최종 마스터(메인+미니 합) → 로컬 스피커 & 공유 스트림
const overallMaster = audioCtx.createGain();
overallMaster.gain.value = 1.0;
mainMasterGain.connect(overallMaster);
miniMasterGain.connect(overallMaster);
overallMaster.connect(audioCtx.destination);

// 공유용 합성 스트림
const shareDest = audioCtx.createMediaStreamDestination();
overallMaster.connect(shareDest);

const state = {
  clips: [],          // {id, file, name, size, audioEl, srcNode, gainNode, loop, route:'main'|'mini', slot:null}
  miniSlots: Array(10).fill(null), // {clipId, name}
  peer: null,
  connectedPeers: new Set(),
  code: null
};

// UI refs
const fileInput = document.getElementById('fileInput');
const mainGrid = document.getElementById('mainGrid');
const miniGrid = document.getElementById('miniGrid');
const masterVol = document.getElementById('masterVol');
const masterVolVal = document.getElementById('masterVolVal');
const miniMasterVol = document.getElementById('miniMasterVol');
const miniMasterVolVal = document.getElementById('miniMasterVolVal');
const stopMainBtn = document.getElementById('stopMain');
const stopMiniBtn = document.getElementById('stopMini');
const makeCodeBtn = document.getElementById('makeCode');
const shareCodeEl = document.getElementById('shareCode');
const peerStatus = document.getElementById('peerStatus');

const saveLSBtn = document.getElementById('saveLS');
const loadLSBtn = document.getElementById('loadLS');
const exportBtn = document.getElementById('exportPreset');
const importInput = document.getElementById('importPreset');

// 초기 미니 슬롯 렌더
function renderMiniGrid() {
  miniGrid.innerHTML = '';
  const keys = ['1','2','3','4','5','6','7','8','9','0'];
  for (let i=0;i<10;i++) {
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.dataset.index = i;
    slot.addEventListener('dragover', (e)=>{ e.preventDefault(); slot.classList.add('drag-over'); });
    slot.addEventListener('dragleave', ()=> slot.classList.remove('drag-over'));
    slot.addEventListener('drop', onSlotDrop);

    const payload = state.miniSlots[i];
    const k = document.createElement('div'); k.className = 'k'; k.textContent = `키 ${keys[i]}`;
    const name = document.createElement('div'); name.className = 'name'; name.textContent = payload?.name || '—';
    slot.appendChild(k);
    slot.appendChild(name);

    // 드래그 가능 핸들(할당된 슬롯만)
    if (payload) {
      const handle = document.createElement('button');
      handle.className = 'btn btn-ghost';
      handle.textContent = '드래그로 이동';
      handle.draggable = true;
      handle.addEventListener('dragstart', (e)=> onSlotDragStart(e, i));
      slot.appendChild(handle);

      const unassignBtn = document.createElement('button');
      unassignBtn.className = 'btn btn-ghost';
      unassignBtn.textContent = '해제';
      unassignBtn.onclick = () => { state.miniSlots[i] = null; renderMiniGrid(); };
      slot.appendChild(unassignBtn);
    }
    miniGrid.appendChild(slot);
  }
}

let draggingSlotIndex = null;
function onSlotDragStart(e, fromIndex){
  draggingSlotIndex = fromIndex;
  e.dataTransfer.setData('text/plain', String(fromIndex));
  e.dataTransfer.effectAllowed = 'move';
}
function onSlotDrop(e){
  e.preventDefault();
  const toIndex = parseInt(this.dataset.index, 10);
  const fromIndex = draggingSlotIndex ?? parseInt(e.dataTransfer.getData('text/plain'),10);
  this.classList.remove('drag-over');
  if (Number.isNaN(fromIndex) || Number.isNaN(toIndex) || fromIndex === toIndex) return;

  // 이동/스왑 처리: from → to (to에 기존 값 있으면 스왑)
  const fromVal = state.miniSlots[fromIndex];
  const toVal = state.miniSlots[toIndex];
  state.miniSlots[toIndex] = fromVal;
  state.miniSlots[fromIndex] = toVal;

  // clip.slot 표시도 갱신
  if (fromVal) {
    const c = state.clips.find(x=> x.id === fromVal.clipId);
    if (c) c.slot = toIndex;
  }
  if (toVal) {
    const c = state.clips.find(x=> x.id === toVal.clipId);
    if (c) c.slot = fromIndex;
  }
  draggingSlotIndex = null;
  renderMiniGrid();
}
renderMiniGrid();

/** ========= 파일 업로드 ========= **/
fileInput.addEventListener('change', async (e) => {
  const files = Array.from(e.target.files || []);
  for (const file of files) {
    const url = URL.createObjectURL(file);
    const audioEl = new Audio(url);
    audioEl.preload = 'auto';
    audioEl.crossOrigin = 'anonymous';
    audioEl.controls = false;
    audioEl.loop = true; // 기본 반복 ON

    const srcNode = audioCtx.createMediaElementSource(audioEl);
    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 1.0;
    srcNode.connect(gainNode).connect(mainMasterGain);

    const clip = {
      id: crypto.randomUUID(),
      file,
      name: file.name,
      size: file.size,
      audioEl,
      srcNode,
      gainNode,
      loop: true,
      route: 'main',
      slot: null
    };
    state.clips.push(clip);
    addClipCard(clip);
  }
  fileInput.value = '';
});

/** ========= 카드 생성 ========= **/
function addClipCard(clip){
  const card = document.createElement('div');
  card.className = 'card';
  card.id = `clip-${clip.id}`;

  const head = document.createElement('div');
  head.className = 'card-head';
  const title = document.createElement('div'); title.className = 'title'; title.textContent = clip.name;
  const badge = document.createElement('div'); badge.className = 'badge'; badge.textContent = '메인 출력';
  head.appendChild(title); head.appendChild(badge);

  const body = document.createElement('div'); body.className = 'card-body';

  // 1) 재생/정지/이어재생 + 삭제
  const ctrlRow = document.createElement('div'); ctrlRow.className = 'controls';
  const playBtn = document.createElement('button'); playBtn.className='btn btn-blue'; playBtn.textContent='재생';
  const pauseBtn = document.createElement('button'); pauseBtn.className='btn'; pauseBtn.textContent='일시정지';
  const resumeBtn = document.createElement('button'); resumeBtn.className='btn'; resumeBtn.textContent='이어재생';
  const delBtn = document.createElement('button'); delBtn.className='btn btn-danger'; delBtn.textContent='삭제';
  playBtn.onclick = ()=>{
    routeClip(clip, 'main', badge);
    clip.audioEl.currentTime = 0; clip.audioEl.play();
  };
  pauseBtn.onclick = ()=> clip.audioEl.pause();
  resumeBtn.onclick = ()=> clip.audioEl.play();
  delBtn.onclick = ()=> deleteClip(clip);
  ctrlRow.appendChild(playBtn); ctrlRow.appendChild(pauseBtn); ctrlRow.appendChild(resumeBtn); ctrlRow.appendChild(delBtn);

  // 2) 반복 토글 (기본 ON)
  const loopRow = document.createElement('div'); loopRow.className = 'controls';
  const loopBtn = document.createElement('button'); loopBtn.className = 'btn';
  const loopLabel = ()=> loopBtn.textContent = '반복: ' + (clip.loop ? 'ON' : 'OFF');
  loopLabel();
  loopBtn.onclick = ()=>{
    clip.loop = !clip.loop;
    clip.audioEl.loop = clip.loop;
    loopLabel();
  };
  loopRow.appendChild(loopBtn);
  loopRow.appendChild(mkSmall('이 음원을 무한 반복할지 선택 (기본 ON)'));

  // 3) 개별 볼륨
  const volWrap = document.createElement('div'); volWrap.className='col';
  const volRow = document.createElement('div'); volRow.className='kv';
  const volTag = document.createElement('span'); volTag.className='pill'; volTag.textContent='개별 볼륨';
  const vol = document.createElement('input'); vol.type='range'; vol.min='0'; vol.max='1'; vol.step='0.01'; vol.value='1.0'; vol.className='range';
  const volVal = document.createElement('span'); volVal.className='small'; volVal.textContent='1.00';
  vol.oninput = ()=> { clip.gainNode.gain.value = parseFloat(vol.value); volVal.textContent = (+vol.value).toFixed(2); };
  volRow.appendChild(volTag); volRow.appendChild(vol); volRow.appendChild(volVal);
  volWrap.appendChild(volRow);

  // 4) 미니보드 할당
  const assignRow = document.createElement('div'); assignRow.className='controls';
  const slotSelect = document.createElement('select'); slotSelect.className='btn';
  const keys = ['1','2','3','4','5','6','7','8','9','0'];
  keys.forEach((k,idx)=> {
    const opt = document.createElement('option'); opt.value = idx; opt.textContent = `키 ${k}`;
    slotSelect.appendChild(opt);
  });
  const assignBtn = document.createElement('button'); assignBtn.className='btn'; assignBtn.textContent='미니보드 할당';
  assignBtn.onclick = ()=>{
    const idx = parseInt(slotSelect.value,10);
    state.miniSlots[idx] = { clipId: clip.id, name: clip.name };
    clip.slot = idx;
    renderMiniGrid();
  };
  assignRow.appendChild(slotSelect); assignRow.appendChild(assignBtn);

  body.appendChild(ctrlRow);
  body.appendChild(loopRow);
  body.appendChild(volWrap);
  body.appendChild(assignRow);

  card.appendChild(head);
  card.appendChild(body);
  mainGrid.appendChild(card);
}

// 유틸: 작은 텍스트
function mkSmall(t){ const s=document.createElement('span'); s.className='small'; s.textContent=t; return s; }

/** ========= 라우팅 제어 ========= **/
function routeClip(clip, route, badgeEl){
  if (clip.route === route) return;
  try { clip.srcNode.disconnect(); } catch(_) {}
  if (route === 'main') {
    clip.srcNode.connect(clip.gainNode).connect(mainMasterGain);
    badgeEl.textContent = '메인 출력';
  } else {
    clip.srcNode.connect(clip.gainNode).connect(miniMasterGain);
    badgeEl.textContent = '미니 출력';
  }
  clip.route = route;
}

/** ========= 삭제 ========= **/
function deleteClip(clip){
  // 재생 중지
  try { clip.audioEl.pause(); } catch(_){}
  // 슬롯에서 제거
  state.miniSlots = state.miniSlots.map(s => s && s.clipId === clip.id ? null : s);
  renderMiniGrid();
  // 오디오 노드 연결 해제
  try { clip.srcNode.disconnect(); } catch(_){}
  try { clip.gainNode.disconnect(); } catch(_){}
  // 리스트/DOM에서 제거
  state.clips = state.clips.filter(c => c.id !== clip.id);
  const card = document.getElementById(`clip-${clip.id}`);
  if (card && card.parentNode) card.parentNode.removeChild(card);
}

/** ========= 보드별 전체 정지 ========= **/
stopMainBtn.onclick = ()=>{
  state.clips.filter(c=>c.route==='main').forEach(c=> c.audioEl.pause());
};
stopMiniBtn.onclick = ()=>{
  state.clips.filter(c=>c.route==='mini').forEach(c=> c.audioEl.pause());
};

/** ========= 마스터 볼륨 ========= **/
masterVol.oninput = ()=>{
  mainMasterGain.gain.value = parseFloat(masterVol.value);
  masterVolVal.textContent = (+masterVol.value).toFixed(2);
};
miniMasterVol.oninput = ()=>{
  miniMasterGain.gain.value = parseFloat(miniMasterVol.value);
  miniMasterVolVal.textContent = (+miniMasterVol.value).toFixed(2);
};

/** ========= 단축키 (미니보드 1~0) ========= **/
window.addEventListener('keydown', (e)=>{
  const map = {'1':0,'2':1,'3':2,'4':3,'5':4,'6':5,'7':6,'8':7,'9':8,'0':9};
  if (!(e.key in map)) return;
  const idx = map[e.key];
  const slot = state.miniSlots[idx];
  if (!slot) return;
  const clip = state.clips.find(c=> c.id === slot.clipId);
  if (!clip) return;

  // 미니 라우트로 보장
  const card = document.getElementById(`clip-${clip.id}`);
  const badgeEl = card?.querySelector('.card-head .badge') || {textContent:''};
  routeClip(clip, 'mini', badgeEl);

  // 반복 설정 유지하여 재생
  clip.audioEl.loop = clip.loop;
  clip.audioEl.currentTime = 0;
  clip.audioEl.play();
});

/** ========= 프리셋 직렬화 ========= **/
function serializePreset(){
  return {
    version: 1,
    mainMaster: mainMasterGain.gain.value,
    miniMaster: miniMasterGain.gain.value,
    clips: state.clips.map(c=> ({
      name: c.name,
      size: c.size ?? null,
      loop: !!c.loop,
      volume: c.gainNode.gain.value,
      route: c.route,
      // 슬롯은 아래 miniSlots에서 별도 관리
    })),
    miniSlots: state.miniSlots.map(s => s ? { name: s.name } : null)
  };
}

// 프리셋을 현재 업로드된 파일들과 매칭(파일명+크기 우선, 크기 없으면 이름만)
function applyPreset(preset){
  if (!preset || !preset.clips) return;

  // 마스터 볼륨
  if (typeof preset.mainMaster === 'number') { mainMasterGain.gain.value = preset.mainMaster; masterVol.value = preset.mainMaster; masterVolVal.textContent = preset.mainMaster.toFixed(2); }
  if (typeof preset.miniMaster === 'number') { miniMasterGain.gain.value = preset.miniMaster; miniMasterVol.value = preset.miniMaster; miniMasterVolVal.textContent = preset.miniMaster.toFixed(2); }

  // 클립 매칭
  preset.clips.forEach(pc => {
    const match = state.clips.find(c => (pc.size!=null && c.size===pc.size && c.name===pc.name) || (pc.size==null && c.name===pc.name));
    if (!match) return;
    match.loop = !!pc.loop;
    match.audioEl.loop = match.loop;
    if (typeof pc.volume === 'number') { match.gainNode.gain.value = pc.volume; }
    if (pc.route === 'mini' || pc.route === 'main') {
      const card = document.getElementById(`clip-${match.id}`);
      const badgeEl = card?.querySelector('.card-head .badge') || {textContent:''};
      routeClip(match, pc.route, badgeEl);
    }
  });

  // 미니 슬롯 재구성(이름으로 찾아 할당)
  state.miniSlots = preset.miniSlots.map((s)=>{
    if (!s) return null;
    const clip = state.clips.find(c=> c.name === s.name);
    return clip ? { clipId: clip.id, name: clip.name } : null;
  });
  // clip.slot도 동기화
  state.clips.forEach(c=> c.slot=null);
  state.miniSlots.forEach((s,idx)=> { if (s){ const c=state.clips.find(x=>x.id===s.clipId); if(c) c.slot=idx; } });
  renderMiniGrid();
}

/** ========= 프리셋: 로컬스토리지 & 파일 ========= **/
const LS_KEY = 'soundboard_preset_v1';

document.getElementById('saveLS').onclick = ()=>{
  const preset = serializePreset();
  localStorage.setItem(LS_KEY, JSON.stringify(preset));
  alert('로컬에 저장되었습니다.');
};

document.getElementById('loadLS').onclick = ()=>{
  const raw = localStorage.getItem(LS_KEY);
  if (!raw) { alert('저장된 프리셋이 없습니다.'); return; }
  try { applyPreset(JSON.parse(raw)); } catch(e){ alert('프리셋 적용 중 오류: '+e.message); }
};

document.getElementById('exportPreset').onclick = ()=>{
  const preset = serializePreset();
  const blob = new Blob([JSON.stringify(preset,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'soundboard_preset.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
};

document.getElementById('importPreset').addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const preset = JSON.parse(text);
    applyPreset(preset);
  } catch (err) {
    alert('프리셋 파일을 읽는 중 오류가 발생했습니다: ' + err.message);
  } finally {
    e.target.value = '';
  }
});

/** ========= 공유 코드 (PeerJS) ========= **/
function genCode() {
  const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let s = "";
  for (let i=0;i<6;i++) s += alphabet[Math.floor(Math.random()*alphabet.length)];
  return s;
}

makeCodeBtn.onclick = ()=>{
  if (state.peer) { alert("이미 코드가 생성되었습니다: " + state.code); return; }
  const code = genCode();
  const peer = new Peer(code, { debug: 1 });
  state.peer = peer;
  state.code = code;
  shareCodeEl.textContent = code;
  peerStatus.textContent = "신호 서버 연결 중…";

  peer.on('open', (id)=>{
    peerStatus.textContent = `준비됨: 코드 ${id} (청취자 접속 시 오디오 전송)`;
  });

  peer.on('connection', (conn)=>{
    state.connectedPeers.add(conn.peer);
    conn.on('open', ()=>{
      const stream = shareDest.stream; // 전체 믹스
      state.peer.call(conn.peer, stream, {metadata:{kind:'mixaudio'}});
      conn.send({type:'hello', now: Date.now(), code: state.code});
      peerStatus.textContent = `연결 ${state.connectedPeers.size}명`;
    });
    conn.on('close', ()=>{
      state.connectedPeers.delete(conn.peer);
      peerStatus.textContent = `연결 ${state.connectedPeers.size}명`;
    });
  });

  peer.on('error', (err)=>{
    console.error(err);
    peerStatus.textContent = '오류: ' + err.message;
    alert("Peer 오류: " + err.message + "\n(다시 시도하거나 다른 코드로 생성해보세요)");
  });

  peer.on('disconnected', ()=>{
    peerStatus.textContent = '신호 서버와 연결 끊김(자동 재시도 중)';
    peer.reconnect();
  });
};
</script>
</body>
</html>
